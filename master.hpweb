fr: Master mot
en: Master Word
master.apl: apl
---
- section: master∆license
  master.apl: 1
- fr: |
    La  partie texte  de  ce  dépôt git  est  distribuée  sous la  licence
    Creative Commons avec attribution et partage dans les mêmes conditions
    (CC-BY-SA). La partie code de ce  dépôt est distribuée sous la licence
    GPL version 1.0 ou ultérieure.
- en: |
    The  text part  of  this repository  is licensed  under  the terms  of
    Creative  Commons, with  attribution and  share-alike (CC-BY-SA).  The
    code part of  this repository is licensed with the  GPL version 1.0 or
    later.
- fr: |
    Ainsi  que le  requiert  la licence  GPL, tout  fichier  de code  doit
    commencer par un  commentaire décrivant de façon  sommaire le logiciel
    et résumant la GPL. La description sommaire en français&nbsp;:

    «&nbsp;Les fonctions de  ce script permettent de  résoudre un problème
    de Master Mot extrait de Télé 7 Jeux.&nbsp;»

    Quant au résumé de la GPL, le  voici, en anglais (je ne suis pas assez
    calé pour traduire en français un texte de teneur juridique).
- en: |
    As  required  by the  GPL,  each  file with  code  must  start with  a
    one-description line of  the program and the summary of  the GPL. Here
    it is.
- code: |
    ∇ master∆license
    'APL program to solve a Master Mot quizz'
    ''
    'Copyright (C) 2025, 2026 Jean Forget  (JFORGET at cpan dot org)'
    ''
    'Build date:'
    ''
    'Portability: L3 (reading text files)'
    ''
    ' This program is distributed under the GNU Public License version 1 or later'
    ''
    ' You can find the text of the license in the LICENSE file or at'
    ' http://www.gnu.org/licenses/gpl-1.0.html.'
    ''
    ' Here is the summary of GPL:'
    ''
    ' This program is free software; you can redistribute it and/or modify'
    ' it under the terms of the GNU General Public License as published by'
    ' the Free Software Foundation; either version 1, or (at your option)'
    ' any later version.'
    ''
    ' This program is distributed in the hope that it will be useful,'
    ' but WITHOUT ANY WARRANTY; without even the implied warranty of'
    ' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the'
    ' GNU General Public License for more details.'
    ''
    ' You should have received a copy of the GNU General Public License'
    ' along with this program; if not, write to the Free Software Foundation,'
    ' Inc., <http://www.fsf.org/>.'
    ∇
- fr: |
    Comme  vous pouvez  le deviner,  ce résumé  fait partie  intégrante du
    logiciel. Donc,  une fois que  vous êtes entrés  sous APL et  que vous
    avez initialisé votre espace de travail avec mon script, vous pouvez à
    tout moment afficher ce résumé.
- en: |
    As  you can  see,  this summary  is executable  code  included in  the
    software.  So, after  you have  logged into  APL and  initialised your
    workspace with my script, you can display this summary at any moment.
- section: 0
  'fr,en': Description
- fr: |
    La revue "Télé  7 Jeux" propose, entre autres,  des problèmes inspirés
    du  Mastermind  et  portant  sur  des  mots  français  de  5  lettres.
    Contrairement au Mastermind  standard, il n'y a pas  de marque blanche
    pour  les  lettres qui  apparaissent  dans  la  solution à  une  place
    incorrecte. Seules les marques noires sont comptabilisées.

    Exemple
- en: |
    The  French  magazine  "Télé  7 Jeux"  provides,  among  others,  game
    problems inspired from Mastermind.  These problems use 5-letter French
    words. Contrary to standard Mastermind,  no white marks are earned for
    letters appearing at the wrong place, only black marks are received.

    Example
- code: |
    paume 2
    choux 1
    pends 1
    foret 1
    palme 1
    fendu 1
    phase 1
    pente 1
    curry 1
    alors 0
- 'fr,en': |
    Solution :
- code: |
    coude
- fr: |
    Tous  les codes  proposés sont  des mots  de la  langue française.  La
    solution elle  aussi est un  mot de  la langue française.  Parfois, le
    problème a  deux solutions, dont un  mot de la langue  française et un
    groupe de  cinq lettres  sans aucune  signification. Mon  programme ne
    tient pas  compte de cette  propriété, il donne  dans ce cas  les deux
    solutions et c'est à l'utilisateur de faire le tri.

    Le  magazine  donne  une   solution  détaillée,  avec  les  déductions
    successives. Par exemple, la première déduction consiste à comparer la ligne <tt>paume</tt> avec la
    ligne <tt>palme</tt>, et à  remarquer que  la lettre en position 3 est
    un  «&nbsp;u&nbsp;».  Mon  programme  ne   cherche  pas  à  faire  des
    déductions, il  effectue une recherche exhaustive  de la combinatoire.
    Enfin, presque  exhaustive. Il commence  par créer la liste  des codes
    partiels à 1  caractère, filtre cette liste, puis génère  la liste des
    codes partiels à 2 caractères, filtre cette nouvelle liste et ainsi de
    suite.
- en: |
    All  codes from  the problem  are  valid French  words. Likewise,  the
    solution is  a French word.  In some rare  cases, the problem  has two
    solutions, one of which is a valid French word and the other is just a
    meaningless lump of  5 letters. In this case, my  program extracts the
    two (or more) solutions and it is  up to the user to select the proper
    one.

    The magazine gives a  detailed solution, with step-by-step deductions.
    With the example above, the first step is comparing code <tt>paume</tt> with
    code <tt>palme</tt> and finding that the letter  at position 3 is "u". My
    program does  not work that way.  It makes an extensive  search of all
    possible  codes. Nearly  extensive,  because it  generates all  1-char
    partial  codes, filters  the list,  builds all  2-char partial  codes,
    filters again and so on.
- section: 0
  fr: Utilisation
  en: Usage
- fr: |
    Pour résoudre  un problème, il  faut commencer par écrire  ce problème
    dans  un  fichier  texte.  Chaque  ligne  de  texte  commence  par  la
    proposition, 5 caractères,  puis un espace (pas plus), puis  la note à
    un  chiffre.  Rien  de  plus.  Le  séparateur  de  ligne  est  le  LF,
    <tt>U+000A</tt>, comme le standard UNIX.

    Les lignes qui ne se conforment pas au modèle 5 caractères + espace + note sont
    ignorées. Cela permet  d'ajouter des lignes techniques  comme dans cet
    exemple.
- en: |
    To solve a problem,  the first step is typing it in  a text file. Each
    line begins  with the 5-char proposition.  It is followed by  a single
    space (no more) and ends with the 1-digit mark. Nothing more. The line
    separator is LF, <tt>U+000A</tt>, as with any standard Unix text file.

    The lines that do not match the pattern 5 chars + space + digit are ignored.
    This allows you to add technical lines as below.

- code: |
    -*- encoding: utf-8; indent-tabs-mode: nil -*-

    paume 2
    choux 1
    pends 1
    foret 1
    palme 1
    fendu 1
    phase 1
    pente 1
    curry 1
    alors 0
- fr: |
    Vous pouvez  utiliser des  lettres majuscules dans  un fichier  et des
    lettres minuscules dans un autre fichier.  Mais ne les mélangez pas au
    sein  d'un  même  fichier.  Quant aux  accents,  trémas  et  cédilles,
    oubliez-les (cf <tt>foret</tt> dans l'exemple ci-dessus).

    Une  fois le  fichier sauvegardé,  ouvrez  APL et  lancez la  fonction
    <tt>@master∆solution@</tt> avec le nom du fichier en  paramètre (entre
    quotes).
- en: |
    You may use lower-caps letters in  a first file and upper-caps letters
    in  another file,  but  do not  mix  them  in the  same  file. As  for
    diacritics, do not use them  (see <tt>foret</tt> in the example above,
    which corresponds to the French word "forêt").

    When   the   file   is   saved,   open   APL   and   launch   function
    <tt>@master∆solution@</tt>, with the  filepath  between  quote  as  an
    argument.
- code: |
    apl -f master.apl
    resul ← @master∆solution@ 'test.data'
    resul
    )off
- fr: |
    Si  l'affichage de  la variable  <tt>resul</tt> ne  donne rien,  c'est
    qu'il n'y a pas de solution. Vous pouvez le vérifier en demandant
- en: |
    If displaying variable <tt>resul</tt>  gives nothing, that means there
    are no solution. You can confirm that by asking
- code: |
    ⍴ result
- fr: |
   qui  doit  répondre  <tt>0  5</tt>.   Voir  les  exemples  fournis  par
   <tt>test0.data</tt> et <tt>test00.data</tt>0

   Vous avez également un exemple de problème à deux solutions, dans <tt>test2.data</tt>.
- en: |
   which   will    answer   <tt>0   5</tt>.   See    the   examples   with
   <tt>test0.data</tt> and <tt>test00.data</tt>0

   File <tt>test2.data</tt> gives you an example which generates two solutions.
- section: 0
  fr: Les programmes
  en: The programs
- fr: |
    Pour écrire les programmes, j'ai  utilisé la variante d'APL des années
    1970 que  j'ai apprise  dans les années  1980, avant  l'apparition des
    fonctions  <i lang='en'>disclose</i>,  <i lang='en'>enclose</i>  et <i
    lang='en'>each</i>  (<tt>⊃⊂¨</tt>). Une  chaîne de  caractères est  en
    fait un  vecteur de caractères, un  vecteur de chaînes est  en fait un
    tableau de caractères (ce qui implique que toutes les chaînes aient la
    même longueur).

    Également, j'utilise  la
    <a href='https://www.gnu.org/software/apl/Library-Guidelines.html'>codification</a>
    qui m'a été  conseillée lorsque j'ai écrit mon
    <a href='https://github.com/jforget/apl-calendar-french'>programme de conversion de calendrier républicain</a>
    même si je n'ai pas l'intention de publier mon programme de Master Mot sur
    <a href='https://www.gnu.org/software/apl/Bits_and_Pieces/'>APL bits and pieces</a>.
- en: |
    To write these programs, I have used the variant of APL from the 1970's, which I
    learnt in the early 1980's, before the advent of "disclose", "enclose"
    and "each" (<tt>⊃⊂¨</tt>). Thus, a string is a vector of chars, and an
    array of strings  is a rectangular table of chars  (which implies that
    all strings must have the same length).

    Likewise, I use the
    <a href='https://www.gnu.org/software/apl/Library-Guidelines.html'>codification</a>
    that I was advised to use when I wrote my
    <a href='https://github.com/jforget/apl-calendar-french'>French Revolutionary calendar program</a>
    even if I have no intention to publish my Master Mot program on
    <a href='https://www.gnu.org/software/apl/Bits_and_Pieces/'>APL bits and pieces</a>.
- section: master∆solution
  master.apl: 9
  level: 3
  fr: Le programme de résolution
  en: The solving program
- fr: |
    Le programme  commence par une phase d'initialisation, qui  consiste à
    lire  le  fichier  et  en  extraire  les  variables  <tt>prop</tt>  et
    <tt>notes</tt>. Ensuite, la résolution se fait ainsi.

    <ol>
    <li>Établir la liste des codes possibles à 1 lettre. C'est le résultat de <tt>@master∆letters@</tt>,
    converti en un tableau à <var>n</var> lignes et 1 colonne.</li>
    <li>Filtrer cette liste de codes possibles.</li>
    <li>Établir la liste des codes possibles à 2 lettres.</li>
    <li>Filtrer cette nouvelle liste de codes possibles.</li>
    </ol>

    Et ainsi de suite jusqu'à la liste filtrée de codes à 5 lettres.

    Notons  qu'il faut  passer une  ligne  avant la  liste des  codes à  5
    lettres,  car cette  liste contient  en général  un seul  code et  son
    affichage se  fait sans passage  à la  ligne. Je pense  qu'il faudrait
    aussi prévoir le cas pour les listes  de codes possibles à 4, ou 3, ou
    2 lettres, mais je fais l'impasse sur ce problème.
- en: |
    The program begins  with an initialisation step, in which  we read the
    file and extract the  variables <tt>prop</tt> and <tt>notes</tt>. Then
    solving the problem is

    <ol>
    <li>Build the list of 1-char possible codes. This is the result of <tt>@master∆letters@</tt>,
    converted to an array with <var>n</var> lines and 1 column.</li>
    <li>Filter this list of possible codes.</li>
    <li>Build the list of 2-char possible codes.</li>
    <li>Filter this new list of possible codes.</li>
    </ol>

    And so on, until we have a filtered list of 5-char codes.

    As you can see, we need to skip to a new line before printing the list
    of 5-char  codes. The  reason is  that usually,  this list  contains a
    single code and therefore it is displayed without changing line. In an
    ideal fashion, we should do the  same when displaying the 4-char codes
    list, the 3-char  codes list and the 2-char codes  list, but actually,
    it  will  not be  necessary  with  usual  Master  Mot problems.  So  I
    disregard this problem.
- code: |
    ∇ r ← master∆solution path; letters; n; poss; prop; notes
    @master∆extract@ path
    n ← ⍴ letters ← @master∆letters@ 1
    ⍞ ← poss ← @master∆filter@ (n, 1) ⍴ letters
    ⍞ ← poss ← @master∆filter@ poss @master∆generation@ @master∆letters@ 2
    ⍞ ← poss ← @master∆filter@ poss @master∆generation@ @master∆letters@ 3
    ⍞ ← poss ← @master∆filter@ poss @master∆generation@ @master∆letters@ 4
    ⍞ ← @master∆nl@
    r ← @master∆filter@ poss @master∆generation@ @master∆letters@ 5
    ∇
- section: master∆slurp
  master.apl: 2
  level: 3
  fr: Chargement du fichier
  en: Loading a file
- fr: |
    Cette  fonction  sert  à  charger   un  fichier  dans  un  vecteur  de
    caractères.  Elle  n'est  pas   portable.  La  version  ci-dessous  ne
    fonctionne  que  sur GNU-APL.  Son  nom  est  inspiré de  la  fonction
    (standard) Raku qui effectue la même tâche.

    La fonction reçoit  en paramètre une chaîne de  caractères (un vecteur
    de caractères) contenant le chemin du  fichier texte à lire. Le chemin
    peut  être relatif  ou absolu,  peu  importe. La  fonction renvoie  un
    vecteur de caractères représentant le contenu du fichier texte.
- en: |
    This function aims to extract the content of a file and load it into a
    char vector. This  function is not portable.  The implementation below
    works  only with  GNU-APL. Its  name  comes from  the (standard)  Raku
    function with the same purpose.

    The  function receives  one parameter,  a string  (char vector)  which
    contains the path to the text file. This can be a relative or absolute
    path, it does not matter. The  function result is another char vector,
    holding the whole content of the text file.
- code: |
    ∇ r ← master∆slurp path
    r ← ⎕FIO[26] path
    ∇
- section: 0
  fr: Chargement du problème
  en: Loading the problem
  level: 3
- fr: |
    Soit un fichier contenant le texte
- en: |
    Let us use a file containing this text
- code: |
    aaaa 1
    bbbb 0
- fr: |
    De manière interne, c'est une suite linéaire de caractères
- en: |
    Its inner structure is a linear sequence of characters
- code: |
    aaaaa(SP)1(LF)bbbbb(SP)0(LF)
- fr: |
    Le programme  commence par générer un  tableau «&nbsp;rotatif&nbsp;» à
    partir de cette suite de caractères.
- en: |
    The  program  begins with  generating  a  "rotating" array  from  this
    sequence
- code: |
    aaaaa(SP)1(LF)bbbbb(SP)0(LF)
    aaaa(SP)1(LF)bbbbb(SP)0(LF)a
    aaa(SP)1(LF)bbbbb(SP)0(LF)aa
    aa(SP)1(LF)bbbbb(SP)0(LF)aaa
    a(SP)1(LF)bbbbb(SP)0(LF)aaaa
    (SP)1(LF)bbbbb(SP)0(LF)aaaaa
    1(LF)bbbbb(SP)0(LF)aaaaa(SP)
    (LF)bbbbb(SP)0(LF)aaaaa(SP)1
    bbbbb(SP)0(LF)aaaaa(SP)1(LF)
    bbbb(SP)0(LF)aaaaa(SP)1(LF)b
    bbb(SP)0(LF)aaaaa(SP)1(LF)bb
    bb(SP)0(LF)aaaaa(SP)1(LF)bbb
    b(SP)0(LF)aaaaa(SP)1(LF)bbbb
    (SP)0(LF)aaaaa(SP)1(LF)bbbbb
    0(LF)aaaaa(SP)1(LF)bbbbb(SP)
    (LF)aaaaa(SP)1(LF)bbbbb(SP)0
- fr: |
     En fait,  de la façon  dont APL fonctionne, en  utilisant <tt>⍳n</tt>
     pour la  rotation avec une origine  des indices <tt>⎕IO</tt> à  1, le
     tableau sera plutôt
- en: |
    Actually,  if using  <tt>⍳n</tt> to  roll  the array,  with the  index
    origin <tt>⎕IO</tt> equal to 1, the rolling array will be rather
- code: |
    aaaa(SP)1(LF)bbbbb(SP)0(LF)a
    ...
    (LF)aaaaa(SP)1(LF)bbbbb(SP)0
    aaaaa(SP)1(LF)bbbbb(SP)0(LF)
- fr: |
    avec la séquence origine à la fin et non pas au début du tableau.

    Puis le programme tronque ces lignes à 9 caractères.
- en: |
    with the  original sequence  at the end  of the array  and not  at its
    beginning.

    Then the program truncates these sequences to 9 chars.
- code: |
    aaaa(SP)1(LF)bb
    aaa(SP)1(LF)bbb
    aa(SP)1(LF)bbbb
    a(SP)1(LF)bbbbb
    (SP)1(LF)bbbbb(SP)
    1(LF)bbbbb(SP)0
    (LF)bbbbb(SP)0(LF)
    bbbbb(SP)0(LF)a
    bbbb(SP)0(LF)aa
    bbb(SP)0(LF)aaa
    bb(SP)0(LF)aaaa
    b(SP)0(LF)aaaaa
    (SP)0(LF)aaaaa(SP)
    0(LF)aaaaa(SP)1
    (LF)aaaaa(SP)1(LF)
    aaaaa(SP)1(LF)b
- fr: |
    Ensuite, le programme filtre cette liste pour conserver uniquement les
    chaînes commençant par un LF et se terminant de même.
- en: |
    Then, the  program filters this  list to keep only  sequences starting
    with a (LF) and ending with another (LF).
- code: |
    (LF)bbbbb(SP)0(LF)
    (LF)aaaaa(SP)1(LF)
- fr: |
    Enfin, le programme extrait le tableau des codes de 5 caractères et le
    tableau des notes.
- en: |
    Lastly, the program extract the array of 5-char codes and the array of
    marks.
- code: |
    bbbbb
    aaaaa
    ---
    0 1
- fr: |
    Les propositions ne  sont pas dans l'ordre initial, mais  ce n'est pas
    grave. L'essentiel est que cet ordre soit conservé dans le tableau des
    notes.

    On peut remarquer que si le  fichier comporte une seule ligne, elle ne
    sera pas  extraite, car  même avec  la rotation,  elle ne  sera jamais
    simultanément précédée  et suivie  par un  (LF). Mais  comment peut-on
    avoir un problème avec un seul coup ?
- en: |
    The  propositions are  not  in the  original order,  but  it does  not
    matter. What  matters is that this  order must be consistent  with the
    order of the array of marks.

    You may  have noticed that  if the file  contains a single  line, this
    line will  not be extracted,  because it will never  be simultaneously
    preceded and followed by a (LF).  But seriously, can you have a Master
    Mot problem consisting of a single line?
- section: master∆nl
  master.apl: 3
  level: 4
  fr: Caractère NL (ou LF) et manque de portabilité
  en: Unportable NL (or LF) char
- fr: |
    Je ne  sais pas comment  spécifier un caractère NL  ou LF dans  le cas
    général. J'admets  que je  n'ai pas trop  regardé. En  revanche, c'est
    facile avec  GNU-APL, il  suffit d'utiliser  un littéral  chaîne entre
    double-quotes.  Mais  ce n'est  pas  portable.  J'isole ce  manque  de
    portabilité dans une ligne de programme unique.
- en: |
    I do  not know how  I can enter  a NL (or LF)  char in a  portable APL
    program. I admit that I have not  searched for very long. On the other
    hand, using  a NL is  easy when  using GNU-APL, I  just have to  use a
    double-quoted string litteral. I isolate this lack of portability in a
    unique program line.
- code: |
     master∆nl ← "\n"
- section: master∆extract
  master.apl: 4
  level: 4
  fr: Extraction des données du problème
  en: Extracting the problem data
- fr: |
    Le programme reçoit le chemin d'accès  du fichier et alimente les deux
    variables  <tt>prop</tt>  et  <tt>notes</tt>.  Il  ne  renvoie  aucune
    valeur.

    Récupération du contenu du fichier
- en: |
    The program  receives the pathname of  the problem file and  feeds two
    variables <tt>prop</tt> and <tt>notes</tt>. There is no return value.

    Loading the content of the file.
- code: |
    ∇ master∆extract path; v; n; t; sel
    v ← @master∆slurp@ path
- fr: |
    Génération du tableau «&nbsp;rotatif&nbsp;» et troncation à 9 colonnes
- en: |
    Generating the rolling array and truncating it to 9 columns
- code: |
    n ← ⍴ v
    t ← ((⍳n) ⌽ (2⍴n) ⍴ v)[;⍳9]
- fr: |
    Filtrons la liste pour conserver les  vecteurs avec un LF en positions
    1 et 9 et un espace en position 7.
- en: |
    The program filters the list to  select line vectors with LF in colums
    1 and 9 and SP in column 7.
- code: |
    sel ← (@master∆nl@ = t[;1]) ∧ (' ' = t[;7]) ∧ @master∆nl@ = t[;9]
    t ← t[sel/⍳n;]
- fr: |
    Extrayons les propositions et les  notes. Pour extraire les  notes, le
    programme prend le chiffre et l'espace qui le précède. Si le programme
    ne  prend pas  l'espace, cela  donne  une chaîne  avec uniquement  des
    chiffres,  donc  l'opérateur  dequote  génère  un  nombre  à  <i>n</i>
    chiffres. L'opérateur dequote est nécessaire  pour avoir un vecteur de
    nombres au lieu d'un vecteur de caractères.
- en: |
    The program extract the propositions  and their notes. When extracting
    the notes, the program takes also  the preceding space. If the program
    does not take this space, the result  would be a string of digits with
    no separator and  the dequote operator would generate  a single number
    with  <i>n</i> digits.  If we  do not  use the  dequote operator,  the
    <tt>notes</tt> variable would contain a vector of chars, while we need
    a vector of numbers.
- code: |
    prop  ← t[;1 + ⍳5]
    notes ← ⍎,t[;7 8]
    ∇
- section: 0
  fr: Génération des différents codes possibles
  en: Generating the various possible codes
  level: 3
- section: master∆letters
  fr: Lettres utilisées pour la position <i>n</i>
  en: Letters used at column <i>n</i>
  master.apl: 5
  level: 4
- fr: |
    Dans Master Mot, la lettre de la solution en colonne <i>n</i> apparaît
    toujours  dans au  moins une  proposition dans  la même  colonne. Pour
    extraire les lettres possibles pour  la colonne <i>n</i>, le programme
    commence par extraire la colonne <i>n</i> en son entier.
- en: |
    In Master  Mot, all  letters of  the solution appear  in at  least one
    proposition,  at the  proper column.  So we  need to  extract all  the
    letters that appear  in column <i>n</i>. For this,  the program begins
    with extracting the whole column.
- code: |
    ∇ r ← master∆letters n; col
    col ← prop[;n]
- fr: |
    Mais il y a des doublons. Pour les éliminer, le programme commence par
    trier les lettres.
- en: |
    But there are duplicates and we  need to eliminate them. For this, the
    program sorts the letters.
- code: |
    col ← col[⍋col]
- fr: |
    Ensuite, il teste  chaque caractère pour savoir s'il est  suivi par un
    caractère identique. Si oui, il le supprime.

    En fait, la logique est  inversée. Le programme teste chaque caractère
    pour savoir s'il  est suivi par un caractère différent.  Si oui, il le
    conserve.
- en: |
    Then it checks  each character, to determine if this  char is followed
    by the same char. In this case, the char is removed from the list.

    Actually, the logic is inverted.  The program checks each character to
    determine if  it is followed  by a different  char. In this  case, the
    char is kept.
- fr: |
    Exemple :
- en: |
    Example:
- 'fr,en': |
    <pre>
    col                         a c c f f p p p p p
    1 ⌽ col                     c c f f p p p p p a
    (col ≠ 1 ⌽ col)             1 0 1 0 1 0 0 0 0 1
    r ← (col ≠ 1 ⌽ col) / col   a   c   f         p
    </pre>
- fr: |
    Une variante consiste à comparer le  caractère testé avec celui qui le
    précède.
- en: |
    A  variant  uses the  comparison  between  the  checked char  and  the
    preceding char.
- 'fr,en': |
    <pre>
    col                         a c c f f p p p p p
    ¯1 ⌽ col                    p a c c f f p p p p
    (col ≠ ¯1 ⌽ col)            1 1 0 1 0 1 0 0 0 0
    r ← (col ≠ ¯1 ⌽ col) / col  a c   f   p
    </pre>
- fr: |
    Remarque : si  la colonne <i>n</i> contient <var>x</var>  fois le même
    caractère, les deux  variantes renvoient un vecteur vide  au lieu d'un
    vecteur avec un seul caractère. Cela peut arriver avec ce problème :
- en: |
    Remark. If column <i>n</i> contains <var>x</var> instances of the same
    character,  both variants  will return  an empty  vector instead  of a
    1-char vector. This may happen with a problem such as:
- 'fr,en': |
    <pre>
    pente 2
    peine 2
    porte 2
    parti 2
    prude 2
    panda 2
    puits 2
    plans 2
    </pre>
- fr: |
    On peut constater que dans la  variante origine, le dernier élément du
    vecteur de sélection est toujours 1, sauf dans le cas problématique de
    la colonne uniforme. De même, dans la variante alternative, le premier
    élément du vecteur de sélection est toujours 1, sauf dans le cas de la
    colonne uniforme. La solution consiste à écraser cet élément par un 1,
    ce qui est neutre  dans le cas général, mais bénéfique  dans le cas de
    la colonne uniforme.
- en: |
    You may  note that  in the  initial variant, the  last element  in the
    selection vector is  always 1, except when applied  to the single-char
    column. Likewise, in  the alternate variant, the first  element in the
    selection vector  is always  1, except when  applied to  a single-char
    column. The  solution consists in  overwriting this element with  a 1,
    which is  a neutral operation in  most cases, and a  beneficial one in
    the case of the single-char column.
- code: |
    r ← (1, 1 ↓ col ≠ ¯1 ⌽ col) / col
    ∇
- 'fr,en': |
    <pre>
    col                                a c c f f p p p p p
    ¯1 ⌽ col                           p a c c f f p p p p
    (col ≠ ¯1 ⌽ col)                   1 1 0 1 0 1 0 0 0 0
    (i, 1 ↓ col ≠ ¯1 ⌽ col)            1 1 0 1 0 1 0 0 0 0
    r ← (i, 1 ↓ col ≠ ¯1 ⌽ col) / col  a c   f   p
    col                                p p p p p p p p p p
    ¯1 ⌽ col                           p p p p p p p p p p
    (col ≠ ¯1 ⌽ col)                   0 0 0 0 0 0 0 0 0 0
    (i, 1 ↓ col ≠ ¯1 ⌽ col)            1 0 0 0 0 0 0 0 0 0
    r ← (i, 1 ↓ col ≠ ¯1 ⌽ col) / col  p
    </pre>
- section: 0
  fr: Génération des codes possibles de <var>n</var> caractères de long
  en: Generating the possible codes with length <var>n</var>
  level: 4
- fr: |
    La génération des  codes possibles de <var>n</var>  caractères se fait
    en prenant  les codes possibles de  <var>n</var> - 1 caractères  et en
    ajoutant un dernier caractère provenant de <tt>@master∆letters@ n</tt>.

    De  par  son  fonctionnement,  la  fonction  <tt>@master∆letters@</tt>
    renvoie un résultat trié. Donc les  codes possibles à 1 caractère sont
    eux aussi triés.  Essayons de conserver cette propriété  pour la liste
    des codes possibles à <var>n</var> caractères.

    Supposons que la liste des codes possibles à 3 caractères soit
- en: |
    To generate  the possible codes  with <var>n</var> chars,  the program
    begins with the list of possible codes with <var>n</var> - 1 chars and
    concatenate them with the chars from <tt>@master∆letters@ n</tt>.

    Because  of the  way  <tt>@master∆letters@</tt> works,  its result  is
    sorted. Therefore the 1-char possible codes are sorted. We try to keep
    this property with the <var>n</var>-char possible codes

    Let us suppose that the 3-char possible codes are
- code: |
     abc
     def
     ghi
- fr: |
     et que la liste (triée) des lettres en colonne 4 soit
- en: |
     and that the (sorted) list of letters for column 4 is
- code: |
     wxyz
- fr: |
    Le résultat attendu est :
- en: |
    The expected result is:
- code: |
     abcw
     abcx
     abcy
     abcz
     defw
     defx
     defy
     defz
     ghiw
     ghix
     ghiy
     ghiz
- fr: |
    Cela se fait en indexant la liste des codes possibles à 3 lettres par
- en: |
    For this, we index the list of 3-char possible codes with
- code: |
     1 1 1 1 2 2 2 2 3 3 3 3
- fr: |
    c'est-à-dire les  nombres 1 à  3 (car  3 possibilités) répétés  4 fois
    (car 4 lettres dans la colonne  ajoutée) et en indexant les lettres de
    la colonne 4 par
- en: |
   that is,  numbers 1 to  3 (because 3  possible codes) repeated  4 times
   (because 4  added letters) and at  the same time we  index the column-4
   letters with
- code: |
     1 2 3 4 1 2 3 4 1 2 3 4
- fr: |
    c'est-à-dire les nombres 1  à 4 (car 4 lettres) répétés  3 fois (car 3
    possibilités dans la génération précédente).
- en: |
    that is, numbers 1 to 4  (because 4 letters) repeated 3 times (because
    3 possible codes in the previous generation).
- section: master∆generation
  master.apl: 6
  level: 4
- fr: |
    Combien de codes possibles et combien de nouvelles lettres ?
- en: |
    How many possible codes and how many new letters?
- code: |
    ∇ r ← poss master∆generation letters; np; nl; ip; il
    np ← ¯1 ↓ ⍴ poss
    nl ← ⍴ letters
- fr: |
    Indices pour les codes possibles et pour les lettres
- en: |
    Indexing the possible codes and the letters.
- code: |
    ip ← (np × nl) ⍴ ⍳ np
    il ← (np × nl) ⍴ ⍳ nl
    ip ← ip[⍋ip]
- fr: |
    Concaténation des codes possibles de la génération précédente avec les
    lettres
- en: |
    Concatenating the possible codes from the previous generation with the
    new letters.
- code: |
    r ← poss[ip;] , letters[il]
    ∇
- section: 0
  fr: Calcul de la note d'une proposition
  en: Computing the note for a proposition
  level: 3
- fr: |
    Si les deux arguments sont des  chaînes à 5 caractères, aucun problème
    pour  calculer la  note. On  compare  les deux  chaînes caractère  par
    caractère, on obtient un vecteur de 5 valeurs booléennes et on fait la
    somme.

    Si les deux arguments sont des  chaînes, mais que l'une d'elle a moins
    de 5 caractères, il  faut tronquer la plus longue à  la longueur de la
    plus  courte, puis  faire la  comparaison caractère  par caractère  et
    sommer le résultat.

    Si les deux arguments sont des listes de chaînes (donc des tableaux de
    caractères), le  calcul de  la note  se fait par  un genre  de produit
    externe. Si par exemple, on a 8 codes possibles et 10 propositions, le
    résultat  doit être  un  tableau d'entiers  avec  la dimension  <tt>(8
    10)</tt>.

    Ainsi, si la variable <tt>prop</tt> vaut
- en: |
    If both parameters  are 5-char codes, no problem to  compute the note.
    The program  compares the corresponding  chars in both  strings, which
    gives a vector with 5 boolean  values. Then we add these boolean value
    (converted to integers 0 or 1) and this is the final result.

    If both  parameters are  strings, but  one of them  is shorter  than 5
    chars, the  program must truncate the  longer string to the  length of
    the shorter one. Then the char-wise  comparison is possible and we can
    convert the booleans to integers and add them.

    If both parameters  are lists of strings, that  is, rectangular arrays
    of chars,  the computation of the  note must be some  kind of external
    product.  For  instance,   if  we  have  8  possible   codes  with  10
    propositions,  then the  result  must  be an  array  of integers  with
    dimension <tt>⍴ = (8 10)</tt>.

    Suppose the <tt>prop</tt> variable contains
- code: |
    pouce
    index
    coude
- fr: |
    et si la variable <tt>poss</tt> contient
- en: |
    and the <tt>poss</tt> variable contains
- code: |
    col
    cou
    pou
- fr: |
    alors le résultat de <tt>poss @master∆note@ prop</tt> donnera
- en: |
    then the result of <tt>poss @master∆note@ prop</tt> will be
- code: |
    .     pouce index coude
    col :   1     0     2
    cou :   2     0     3
    pou :   3     0     2
- fr: |
    Conceptuellement, l'utilisation de <tt>@master∆note@</tt> sur un vecteur
    de  codes possibles  et un  vecteur de  propositions donne  un tableau
    <tt>poss ∘.noter  prop</tt> avec  un produit externe  (<i>jot</i>). En
    réalité, le tableau  des codes possibles est, dans ce  cas, un tableau
    <tt>⍴ = 3  3</tt> de caractères et le tableau  des propositions, après
    troncation, est lui  aussi un tableau <tt>⍴ = 3  3</tt> de caractères.
    Le calcul se fait par un produit interne <tt>+.=</tt>
- en: |
    In  an abstract fashion, using <tt>@master∆note@</tt> on  a vector  of
    possible codes and on a vector  of proposition gives an array <tt>poss
    ∘.note prop</tt> with an  external product (<i>jot</i>). Actually, the
    vector of possible  codes is an array  of chars with <tt>⍴  = 3 3</tt>
    and, after truncation  the vector of propositions is also  an array of
    chars with <tt>⍴ = 3 3</tt>. The computation of the notes is therefore
    done with an internal product <tt>+.=</tt>
- code: |
    .     p   i   c
    .     o   n   o
    .     u   d   u
    .
    col   1   0   2
    cou   2   0   3
    pou   3   0   2
- section: master∆note
  master.apl: 7
  level: 4
- fr: |
    Calculer la dimension pour tronquer les deux paramètres.
- en: |
    Compute the dimension to truncate both parameters.
- code: |
    ∇ r ← poss master∆note prop; d1; d2; l1; l2; lmin; posst; propt
    l1   ← ¯1 ↑ d1 ← ⍴ poss
    l2   ← ¯1 ↑ d2 ← ⍴ prop
    lmin ← l1 ⌊ l2
    d1   ← (¯1 ↓ d1), lmin
    d2   ← (¯1 ↓ d2), lmin
- fr: |
    Tronquer les codes possibles et les propositions à la longueur la plus
    petite. On  en profite pour  transposer le second paramètre,  de façon
    qu'il soit bien disposé pour le calcul.
- en: |
    Truncating  the  possible codes  and  the  propositions to  the  lower
    dimension.  At  the  same  time, the  program  transposes  the  second
    parameter, so it will be ready for the internal product.
- code: |
    posst ←   d1 ↑ poss
    propt ← ⍉ d2 ↑ prop
- fr: |
    Calculer le tableau des notes.
- en: |
    Compute the array of notes.
- code: |
    r ← posst +.= propt
    ∇
- section: master∆filter
  fr: Filtrer la liste des codes possibles
  en: Sifting through the list of possible codes
  master.apl: 8
  level: 3
- fr: |
    Un code  possible tronqué est  compatible avec une proposition  si les
    deux conditions suivantes sont vérifiées&nbsp;:

    <ol>
    <li>la note reçue est inférieure ou égale à la note finale de la proposition,</li>

    <li>la  note reçue  est supérieure  ou égale  à la  note finale  de la
    proposition moins  le nombre de  places vides.</li>

    </ol>

    À  l'inverse,  un code  possible  tronqué  est incompatible  avec  une
    proposition si une de ces deux conditions est vérifiée&nbsp;:

    <ol>  <li>la  note  reçue  est  supérieure à  la  note  finale  de  la
    proposition. Avec  l'ajout de lettres  dans les places  manquantes, la
    note ne pourra pas redescendre à la valeur attendue.</li>

    <li>la note  reçue est inférieure à  la note finale de  la proposition
    moins le  nombre de places  vides. Même  si le remplissage  des places
    vides  donne lieu  à l'ajout  de fiches  noires, nous  sommes trop  en
    retard pour retrouver la note finale.</li>

    </ol>

    Exemple. La proposition est <tt>'pouce'</tt>  et sa note finale est 3.
    Le programme teste le code <tt>'ro'</tt>.  Sa note est 1, le nombre de
    places vides est 3. Comme la note  1 est inférieure ou égale à la note
    finale 3, et comme  la note 1 est supérieure ou  égale à la différence
    3-3 (note finale - places vides), alors le code est compatible.

    Testons maintenant le  code possible <tt>'rif'</tt>. Sa note  est 0 et
    le nombre de places vides est 2.  La note reçue est bien inférieure ou
    égale à  la note  finale 3, mais  d'un autre côté,  la note  reçue est
    inférieure à la différence (note finale - places vides), qui vaut 3-2,
    soit 1. Le code <tt>'rif'</tt> n'est donc pas compatible.

    Finalement, le code <tt>'pouc'</tt> n'est  pas compatible, car sa note
    reçue est 4, plus grande que la note finale 3.

    Maintenant,  examinons  le  cas  du  filtrage  d'une  liste  de  codes
    possibles  en fonction  d'une liste  de propositions.  Considérons les
    propositions et codes suivants.
- en: |
    A  partial code  is compatible  with a  proposition if  both following
    conditions are fulfilled:

    <ol>
    <li>The assigned note is lower than or equal to the proposition's final note.</li>

    <li>The assigned  note is greater  than or equal to  the proposition's
    final note minus the number of still empty slots. That means that even
    if the filling of each empty slot  brings a new black mark, we are too
    much behind to reach the final note.</li>

    </ol>

    On the other  hand, a partial code is incompatible  with a proposition
    if either condition is fulfilled:

    <ol>

    <li>The assigned  note is greater  than the proposition's  final note.
    When filling the empty slots, the note will increase or stay the same,
    it cannot decrease to reach the target value.</li>

    <li>The assigned note is lower than the proposition's final note minus
    the number of  still empty slots. That means that  even if the filling
    of each empty slot brings a new  black mark, we are too much behind to
    reach the final note.</li>

    </ol>

    Example. The proposition is <tt>'pouce'</tt>  with a final note 3. The
    program checks the truncated code <tt>'ro'</tt>. Its note is 1 and the
    number of empty slots is 3. Since note 1 is lower than or equal to the
    final note 3, and since it is  greater than or equalt to the result of
    3-3 (final  note - empty  slots), the truncated code  <tt>'ro'</tt> is
    compatible.

    Now  we check  possible code  <tt>'rif'</tt>. Its  note is  0 and  the
    number of  empty slots is  2. On  one hand the  note is lower  than or
    equal to the final note 3, but on  the other hand it is lower than the
    difference 3-2 (final note -  empty slots). Code <tt>'rif'</tt> is not
    compatible.

    A last example is code  <tt>'pouc'</tt>. It is not compatible, because
    its note is 4, which is greater than the final note 3.

    Now, let us  examine how filtering work with a  list of possible codes
    against a list of propositions. We use the following examples.
- 'fr,en': |
    <pre>
    coupe 4
    paume 2
    choux 1
          coupe paume choux
    cou :   3     1     1
    cha :   1     0     2
    phi :   0     1     1
    </pre>
- fr: |
    Le test de la première condition sera
- en: |
    Checking the first condition will be
- 'fr,en': |
    <pre>
    ( 1   1   1 )       ( 3   1   1 )       ( 4   2   1 )
    ( 1   1   0 )   ←   ( 1   0   2 )   ≤   ( 4   2   1 )
    ( 1   1   1 )       ( 0   1   1 )       ( 4   2   1 )
    </pre>
- fr: |
    Le test de la deuxième condition sera
- en: |
    Checking the second condition will be
- 'fr,en': |
    <pre>
    ( 1   1   1 )       ( 3   1   1 )       ( 2   0   ¯1 )
    ( 0   1   1 )   ←   ( 1   0   2 )   ≥   ( 2   0   ¯1 )
    ( 0   1   1 )       ( 0   1   1 )       ( 2   0   ¯1 )
    </pre>
- fr: |
    Comme  on peut  le voir,  les notes  des propositions  (un vecteur  de
    dimension 3) doivent  être réorganisées en un tableau 3×3,  à savoir 1
    ligne par code possible et une colonne par proposition.
- en: |
    As you can  see in this example, the propositions'  notes (vector with
    dimension 3) must  be reorganised as a 3×3 array:  1 line per possible
    code, 1 column per proposition.
- code: |
    ∇ r ← master∆filter poss; empty; npr; dim; sel1; sel2; sel
    empty ← 5 - ¯1 ↑ ⍴ poss
    dim   ← ⍴ npr ← poss @master∆note@  prop
    sel1  ← npr ≤ dim ⍴ notes
    sel2  ← npr ≥ (dim ⍴ notes) - empty
    sel   ← ∧ / sel1, sel2
    r ← sel ⌿ poss
    ∇
- section: 0
  fr: Les fichiers de tests
  en: Test files
- fr: |
     Je ne diffuse pas les problèmes  extraits de Télé 7 Jeux que j'ai
     collectés depuis plusieurs années. J'ai  le droit de les recopier
     pour une  utilisation personnelle, mais pas  pour une utilisation
     collective.   J'ai   imaginé    un   problème   similaire,   dans
     <tt>test.data</tt>, mais qui n'est tiré d'aucun problème existant
     (ou alors, il s'agirait d'une coïncidence).

     Similaire à  <tt>test.data</tt>, il y a  <tt>test2.data</tt>, qui
     admet deux solutions  et non pas une seule. Comme  dans les rares
     problèmes  de  Télé 7  Jeux  admettant  plusieurs solutions,  une
     solution est  un mot  correct, l'autre est  un groupe  de lettres
     sans signification.

     Le  fichier  <tt>test1.data</tt>  admet une  seule  solution.  Sa
     particularité est  que l'une des colonnes  (la première) contient
     une seule lettre.

     Les  fichiers <tt>test0.data</tt>  et <tt>test00.data</tt>  n'ont
     pas  de solution.  Dans le  cas de  <tt>test0.data</tt>, cela  se
     produit lors de la dernière itération,  tandis que dans le cas de
     <tt>test00.data</tt> cela se produit avant la dernière itération.
- en: |
     I  do not  publish the  problems from  Télé 7  Jeux which  I have
     gathered for  several years.  I am  allowed to  copy them  for my
     private use,  but I am not  allowed to use them  for a collective
     use. So I  have created a similar  problem in <tt>test.data</tt>,
     which  is  not among  the  published  problems.  Or it  has  been
     published before I  started collecting them, but this  would be a
     coincidence.

     Similar to <tt>test.data</tt>, there is <tt>test2.data</tt>, with
     two fewer lines. This problem has  two solutions. As the very few
     Télé  7  Jeux  problems  with  two  solutions,  one  solution  of
     <tt>test2.data</tt> is a real French word  and the other one is a
     bunch of letters without any meaning.

     File <tt>test1.data</tt>  accepts a single solution.  Its purpose
     is to check  the solving program when a column  contains a single
     letter.

     Test files  <tt>test0.data</tt> and <tt>test00.data</tt>  have no
     solutions.  For  <tt>test0.data</tt>,  the   failure  to  find  a
     solution happens at  the last iteration of  the (flattened) loop,
     while for <tt>test00.data</tt>, it happens earlier.
