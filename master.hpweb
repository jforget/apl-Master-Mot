fr: Master mot
en: Master Word
master.apl: apl
---
- section: master∆license
  master.apl: 1
- fr: |
    La  partie texte  de  ce  dépôt git  est  distribuée  sous la  licence
    Creative Commons avec attribution et partage dans les mêmes conditions
    (CC-BY-SA). La partie code de ce  dépôt est distribuée sous la licence
    GPL version 1.0 ou ultérieure.
- en: |
    The  text part  of  this repository  is licensed  under  the terms  of
    Creative  Commons, with  attribution and  share-alike (CC-BY-SA).  The
    code part of  this repository is licensed with the  GPL version 1.0 or
    later.
- fr: |
    Ainsi  que le  requiert  la licence  GPL, tout  fichier  de code  doit
    commencer par un  commentaire décrivant de façon  sommaire le logiciel
    et résumant la GPL. La description sommaire en français&nbsp;:

    «&nbsp;Les fonctions de  ce script permettent de  résoudre un problème
    de Master Mot extrait de Télé 7 Jeux.&nbsp;»

    Quant au résumé de la GPL, le  voici, en anglais (je ne suis pas assez
    calé pour traduire en français un texte de teneur juridique).
- en: |
    As  required  by the  GPL,  each  file with  code  must  start with  a
    one-description line of  the program and the summary of  the GPL. Here
    it is.
- code: |
    ∇ master∆license
    'APL program to solve a Master Mot quizz'
    ''
    'Copyright (C) 2025 Jean Forget  (JFORGET at cpan dot org)'
    ''
    'Build date:'
    ''
    'Portability: L3 (reading text files)'
    ''
    ' This program is distributed under the GNU Public License version 1 or later'
    ''
    ' You can find the text of the license in the LICENSE file or at'
    ' http://www.gnu.org/licenses/gpl-1.0.html.'
    ''
    ' Here is the summary of GPL:'
    ''
    ' This program is free software; you can redistribute it and/or modify'
    ' it under the terms of the GNU General Public License as published by'
    ' the Free Software Foundation; either version 1, or (at your option)'
    ' any later version.'
    ''
    ' This program is distributed in the hope that it will be useful,'
    ' but WITHOUT ANY WARRANTY; without even the implied warranty of'
    ' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the'
    ' GNU General Public License for more details.'
    ''
    ' You should have received a copy of the GNU General Public License'
    ' along with this program; if not, write to the Free Software Foundation,'
    ' Inc., <http://www.fsf.org/>.'
    ∇
- fr: |
    Comme  vous pouvez  le deviner,  ce résumé  fait partie  intégrante du
    logiciel. Donc,  une fois que  vous êtes entrés  sous APL et  que vous
    avez initialisé votre espace de travail avec mon script, vous pouvez à
    tout moment afficher ce résumé.
- en: |
    As  you can  see,  this summary  is executable  code  included in  the
    software.  So, after  you have  logged into  APL and  initialised your
    workspace with my script, you can display this summary at any moment.
- section: 0
  'fr,en': Description
- fr: |
    La revue "Télé  7 Jeux" propose, entre autres,  des problèmes inspirés
    du  Mastermind  et  portant  sur  des  mots  français  de  5  lettres.
    Contrairement au Mastermind  standard, il n'y a pas  de marque blanche
    pour  les  lettres qui  apparaissent  dans  la  solution à  une  place
    incorrecte. Seules les marques noires sont comptabilisées.

    Exemple
- en: |
    The  French  magazine  "Télé  7 Jeux"  provides,  among  others,  game
    problems inspired from Mastermind.  These problems use 5-letter French
    words. Contrary to standard Mastermind,  no white marks are earned for
    letters appearing at the wrong place, only black marks are received.

    Example
- code: |
    paume 2
    choux 1
    pends 1
    foret 1
    palme 1
    fendu 1
    phase 1
    pente 1
    curry 1
    alors 0
- 'fr,en': |
    Solution :
- code: |
    coude
- fr: |
    Tous  les codes  proposés sont  des mots  de la  langue française.  La
    solution elle  aussi est un  mot de  la langue française.  Parfois, le
    problème a  deux solutions, dont un  mot de la langue  française et un
    groupe de  cinq lettres  sans aucune  signification. Mon  programme ne
    tient pas  compte de cette  propriété, il donne  dans ce cas  les deux
    solutions et c'est à l'utilisateur de faire le tri.

    Le  magazine  donne  une   solution  détaillée,  avec  les  déductions
    successives. Par exemple, en comparant la ligne <tt>paume</tt> avec la
    ligne <tt>palme</tt>, nous remarquons que  la lettre en position 3 est
    un  «&nbsp;u&nbsp;».  Mon  programme  ne   cherche  pas  à  faire  des
    déductions, il  effectue une recherche exhaustive  de la combinatoire.
    Enfin, presque  exhaustive. Il commence  par créer la liste  des codes
    partiels à 1  caractère, filtre cette liste, puis génère  la liste des
    codes partiels à 2 caractères, filtre cette nouvelle liste et ainsi de
    suite.
- en: |
    All  codes from  the problem  are  valid French  words. Likewise,  the
    solution is  a French word.  In some rare  cases, the problem  has two
    solutions, one of which is a valid French word and the other is just a
    meaningless lump of  5 letters. In this case, my  program extracts the
    two (or more) solutions and it is  up to the user to select the proper
    one.

    The magazine gives a  detailed solution, with step-by-step deductions.
    With the example above, the solution compares code <tt>paume</tt> with
    <tt>palme</tt> and concludes that the letter  at position 3 is "u". My
    program does  not work that way.  It makes an extensive  search of all
    possible  codes. Nearly  extensive,  because it  generates all  1-char
    partial  codes, filters  the list,  builds all  2-char partial  codes,
    filters again and so on.
- section: 0
  fr: Utilisation
  en: Usage
- fr: |
    Pour résoudre  un problème, il  faut commencer par écrire  ce problème
    dans  un  fichier  texte.  Chaque  ligne  de  texte  commence  par  la
    proposition, 5 caractères,  puis un espace (pas plus), puis  la note à
    un  chiffre.  Rien  de  plus.  Le  séparateur  de  ligne  est  le  LF,
    <tt>U+000A</tt>, comme le standard UNIX.

    Les lignes qui ne  se conforment pas au modèle 5 +  espace + note sont
    ignorées. Cela permet  d'ajouter des lignes techniques  comme dans cet
    exemple.
- en: |
    To solve a problem,  the first step is typing it in  a text file. Each
    line begins  with the 5-char proposition.  It is followed by  a single
    space (no more) and ends with the 1-digit mark. Nothing more. The line
    separator is LF, <tt>U+000A</tt>, as with any standard Unix text file.

    The lines that do not match the pattern 5 + space + digit are ignored.
    This allows you to add technical lines as below.
- code: |
    -*- encoding: utf-8; indent-tabs-mode: nil -*-

    paume 2
    choux 1
    pends 1
    foret 1
    palme 1
    fendu 1
    phase 1
    pente 1
    curry 1
    alors 0
- fr: |
    Vous pouvez  utiliser des  lettres majuscules dans  un fichier  et des
    lettres minuscules dans un autre fichier.  Mais ne les mélangez pas au
    sein  d'un  même  fichier.  Quant  aux  écrans,  trémas  et  cédilles,
    oubliez-les (cf <tt>foret</tt> dans l'exemple ci-dessus).
- en: |
    You may use lower-caps letters in  a first file and upper-caps letters
    in  another file,  but  do not  mix  them  in the  same  file. As  for
    diacritics, do not use them  (see <tt>foret</tt> in the example above,
    which corresponds to the French word "forêt").
- section: 0
  fr: Les programmes
  en: The programs
- fr: |
    Pour écrire  les programmes, j'ai  utilisé la variante d'APL  que j'ai
    apprise  dans les  années 1980,  avant l'apparition  des fonctions  <i
    lang='en'>disclose</i>,     <i     lang='en'>enclose</i>     et     <i
    lang='en'>each</i>  (<tt>⊃⊂¨</tt>). Une  chaîne de  caractères est  en
    fait un  vecteur de caractères, un  vecteur de chaînes est  en fait un
    tableau de caractères (ce qui implique que toutes les chaînes aient la
    même longueur).

    Également, j'utilise  la
    <a href='https://www.gnu.org/software/apl/Library-Guidelines.html'>codification</a>
    qui m'a été  conseillée lorsque j'ai écrit mon
    <a href='https://github.com/jforget/apl-calendar-french'>programme de conversion de calendrier républicain</a>
    même si je n'ai pas l'intention de publier mon programme de Master Mot sur
    <a href='https://www.gnu.org/software/apl/Bits_and_Pieces/'>APL bits and pieces</a>.
- en: |
    To write these programs,  I have used the old variant  of APL, which I
    learnt in the early 1980's, before the advent of "disclose", "enclose"
    and "each" (<tt>⊃⊂¨</tt>). Thus, a string is a vector of chars, and an
    array of strings  is a rectangular table of chars  (which implies that
    all strings must have the same length).

    Likewise, I use the
    <a href='https://www.gnu.org/software/apl/Library-Guidelines.html'>codification</a>
    that I was advised to use when I wrote my
    <a href='https://github.com/jforget/apl-calendar-french'>French Revolutionary calendar program</a>
    even if I have no intention to publish my Master Mot program on
    <a href='https://www.gnu.org/software/apl/Bits_and_Pieces/'>APL bits and pieces</a>.
- section: master∆slurp
  master.apl: 2
  level: 3
  fr: Chargement du fichier
  en: Loading a file
- fr: |
    Cette  fonction  sert  à  charger   un  fichier  dans  un  vecteur  de
    caractères.  Elle  n'est  pas   portable.  La  version  ci-dessous  ne
    fonctionne  que  sur GNU-APL.  Son  nom  est  inspiré de  la  fonction
    (standard) Raku qui effectue la même tâche.

    La fonction reçoit  en paramètre une chaîne de  caractères (un vecteur
    de caractères) contenant le chemin du  fichier texte à lire. Le chemin
    peut  être relatif  ou absolu,  peu  importe. La  fonction renvoie  un
    vecteur de caractères représentant le contenu du fichier texte.
- en: |
    This function aims to extract the content of a file and load it into a
    char vector. This  function is not portable.  The implementation below
    works  only with  GNU-APL. Its  name  comes from  the (standard)  Raku
    function with the same purpose.

    The  function receives  one parameter,  a string  (char vector)  which
    contains the path to the text file. This can be a relative or absolute
    path, it does not matter. The  function result is another char vector,
    holding the whole content of the text file.
- code: |
    ∇ r ← master∆slurp path
    r ← ⎕FIO[26] path
    ∇
- section: 0
  fr: Chargement du problème
  en: Loading the problem
  level: 3
- fr: |
    Soit un fichier contenant le texte
- en: |
    Let us use a file containing this text
- code: |
    aaaa 1
    bbbb 0
- fr: |
    De manière interne, c'est une suite linéaire de caractères
- en: |
    Its inner structure is a linear sequence of characters
- code: |
    aaaaa(SP)1(LF)bbbbb(SP)0(LF)
- fr: |
    Le programme  commence par générer un  tableau «&nbsp;rotatif&nbsp;» à
    partir de cette suite de caractères.
- en: |
    The  program  begins with  generating  a  "rotating" array  from  this
    sequence
- code: |
    aaaaa(SP)1(LF)bbbbb(SP)0(LF)
    aaaa(SP)1(LF)bbbbb(SP)0(LF)a
    aaa(SP)1(LF)bbbbb(SP)0(LF)aa
    aa(SP)1(LF)bbbbb(SP)0(LF)aaa
    a(SP)1(LF)bbbbb(SP)0(LF)aaaa
    (SP)1(LF)bbbbb(SP)0(LF)aaaaa
    1(LF)bbbbb(SP)0(LF)aaaaa(SP)
    (LF)bbbbb(SP)0(LF)aaaaa(SP)1
    bbbbb(SP)0(LF)aaaaa(SP)1(LF)
    bbbb(SP)0(LF)aaaaa(SP)1(LF)b
    bbb(SP)0(LF)aaaaa(SP)1(LF)bb
    bb(SP)0(LF)aaaaa(SP)1(LF)bbb
    b(SP)0(LF)aaaaa(SP)1(LF)bbbb
    (SP)0(LF)aaaaa(SP)1(LF)bbbbb
    0(LF)aaaaa(SP)1(LF)bbbbb(SP)
    (LF)aaaaa(SP)1(LF)bbbbb(SP)0
- fr: |
     En fait,  de la façon  dont APL fonctionne, en  utilisant <tt>⍳n</tt>
     pour la  rotation avec une origine  des indices <tt>⎕IO</tt> à  1, le
     tableau sera plutôt
- en: |
    Actually,  if using  <tt>⍳n</tt> to  roll  the array,  with the  index
    origin <tt>⎕IO</tt> equal to 1, the rolling array will be rather
- code: |
    aaaa(SP)1(LF)bbbbb(SP)0(LF)a
    ...
    (LF)aaaaa(SP)1(LF)bbbbb(SP)0
    aaaaa(SP)1(LF)bbbbb(SP)0(LF)
- fr: |
    avec la séquence origine à la fin et non pas au début du tableau.

    Puis le programme tronque ces lignes à 9 caractères.
- en: |
    with the  original sequence  at the end  of the array  and not  at its
    beginning.

    Then the program truncates these sequences to 9 chars.
- code: |
    aaaa(SP)1(LF)bb
    aaa(SP)1(LF)bbb
    aa(SP)1(LF)bbbb
    a(SP)1(LF)bbbbb
    (SP)1(LF)bbbbb(SP)
    1(LF)bbbbb(SP)0
    (LF)bbbbb(SP)0(LF)
    bbbbb(SP)0(LF)a
    bbbb(SP)0(LF)aa
    bbb(SP)0(LF)aaa
    bb(SP)0(LF)aaaa
    b(SP)0(LF)aaaaa
    (SP)0(LF)aaaaa(SP)
    0(LF)aaaaa(SP)1
    (LF)aaaaa(SP)1(LF)
    aaaaa(SP)1(LF)b
- fr: |
    Ensuite, le programme filtre cette liste pour conserver uniquement les
    chaînes commençant par un LF et se terminant de même.
- en: |
    Then, the  program filters this  list to keep only  sequences starting
    with a (LF) and ending with another (LF).
- code: |
    (LF)bbbbb(SP)0(LF)
    (LF)aaaaa(SP)1(LF)
- fr: |
    Enfin, le programme extrait le tableau des codes de 5 caractères et le
    tableau des notes.
- en: |
    Lastly, the program extract the array of 5-char codes and the array of
    marks.
- code: |
    bbbbb
    aaaaa
    ---
    0 1
- fr: |
    Les propositions ne  sont pas dans l'ordre initial, mais  ce n'est pas
    grave. L'essentiel est que cet ordre soit conservé dans le tableau des
    notes.

    On peut remarquer que si le  fichier comporte une seule ligne, elle ne
    sera pas  extraite, car  même avec  la rotation,  elle ne  sera jamais
    simultanément précédée  et suivie  par un  (LF). Mais  comment peut-on
    avoir un problème avec un seul coup ?
- en: |
    The  propositions are  not  in the  original order,  but  it does  not
    matter. What  matters is that this  order must be consistent  with the
    order of the array of marks.

    You may  have noticed that  if the file  contains a single  line, this
    line will  not be extracted,  because it will never  be simultaneously
    preceded and followed by a (LF).  But seriously, can you have a Master
    Mot problem consisting of a single line?
- section: master∆nl
  master.apl: 3
  level: 4
  fr: Caractère NL (ou LF) et manque de portabilité
  en: Unportable NL (or LF) char
- fr: |
    Je ne  sais pas comment  spécifier un caractère NL  ou LF dans  le cas
    général. J'admets  que je  n'ai pas trop  regardé. En  revanche, c'est
    facile avec  GNU-APL, il  suffit d'utiliser  un littéral  chaîne entre
    double-quotes.  Mais  ce n'est  pas  portable.  J'isole ce  manque  de
    portabilité dans une ligne de programme unique.
- en: |
    I do  not know how  I can enter  a NL (or LF)  char in a  portable APL
    program. I admit that I have not  searched for very long. On the other
    hand, using  a NL is  easy when  using GNU-APL, I  just have to  use a
    double-quoted string litteral. I isolate this lack of portability in a
    unique program line.
- code: |
     master∆nl ← "\n"
- section: master∆extract
  master.apl: 4
  level: 4
  fr: Extraction des données du problème
  en: Extracting the problem data
- fr: |
    Le programme reçoit le chemin d'accès  du fichier et alimente les deux
    variables  globales <tt>prop</tt>  et  <tt>notes</tt>.  Il ne  renvoie
    aucune valeur.

    Récupération du contenu du fichier
- en: |
    The program  receives the pathname of  the problem file and  feeds two
    global variables <tt>prop</tt> and  <tt>notes</tt>. There is no return
    value.

    Loding the content of the file.
- code: |
    ∇ master∆extract path; v; n; t; sel
    v ← @master∆slurp@ path
- fr: |
    Génération du tableau «&nbsp;rotatif&nbsp;» et troncation à 9 colonnes
- en: |
    Generating the rolling array and truncating it to 9 columns
- code: |
    n ← ⍴ v
    t ← ((⍳n) ⌽ (2⍴n) ⍴ v)[;⍳9]
- fr: |
    Filtrons la liste pour conserver les  vecteurs avec un LF en positions
    1 et 9 et un espace en position 7.
- en: |
    The program filters the list to  select line vectors with LF in colums
    1 and 9 and SP in column 7.
- code: |
    sel ← (@master∆nl@ = t[;1]) ∧ (' ' = t[;7]) ∧ @master∆nl@ = t[;9]
    t ← t[sel/⍳n;]
- fr: |
    Extrayons les  proposition et les  notes. Pour extraire les  notes, le
    programme prend le chiffre et l'espace qui le précède. Si le programme
    ne  prend pas  l'espace, cela  donne  une chaîne  avec uniquement  des
    chiffres,  donc  l'opérateur  dequote  génère  un  nombre  à  <i>n</i>
    chiffres. L'opérateur dequote est nécessaire  pour avoir un vecteur de
    nombres au lieu d'un vecteur de caractères.
- en: |
    The program extract the propositions  and their notes. When extracting
    the notes, the program takes also  the preceding space. If the program
    does not take this space, the result  would be a string of digits with
    no separator and  the dequote operator would generate  a single number
    with  <i>n</i> digits.  If we  do not  use the  dequote operator,  the
    <tt>notes</tt> variable would contain a vector of chars, while we need
    a vector of numbers.
- code: |
    prop  ← t[;1 + ⍳5]
    notes ← ⍎,t[;7 8]
    ∇
- section: 0
  fr: Génération des différents codes possibles
  en: Generating the various possible codes
  level: 3
- section: master∆letters
  fr: Lettres utilisées pour la position <i>n</i>
  en: Letters used at column <i>n</i>
  master.apl: 5
  level: 4
- fr: |
    Dans Master Mot, la lettre de la solution en colonne <i>n</i> apparaît
    toujours  dans au  moins une  proposition dans  la même  colonne. Pour
    extraire les lettres possibles pour  la colonne <i>n</i>, le programme
    commence par extraire la colonne <i>n</i> en son entier.
- en: |
    In Master  Mot, all  letters of  the solution appear  in at  least one
    proposition,  at the  proper column.  So we  need to  extract all  the
    letters that appear  in column <i>n</i>. For this,  the program begins
    with extracting the whole column.
- code: |
    ∇ r ← master∆letters n; col
    col ← prop[;n]
- fr: |
    Mais il y a des doublons. Pour les éliminer, le programme commence par
    trier les lettres.
- en: |
    But there are duplicates and we  need to eliminate them. For this, the
    program sorts the letters.
- code: |
    col ← col[⍋col]
- fr: |
    Ensuite, il teste  chaque caractère pour savoir s'il est  suivi par un
    caractère identique. Si oui, il le supprime.

    En fait, la logique est  inversée. Le programme teste chaque caractère
    pour savoir s'il  est suivi par un caractère différent.  Si oui, il le
    conserve.
- en: |
    Then it checks  each character, to determine if this  char is followed
    by the same char. In this case, the char is removed from the list.

    Actually, the logic is inverted.  The program checks each character to
    determine if  it is followed  by a different  char. In this  case, the
    char is kept.
- code: |
    r ← (col ≠ 1 ⌽ col) / col
    ∇
- fr: |
    Remarque : si  la colonne <i>n</i> contient <var>x</var>  fois le même
    caractère, la  fonction renvoie un  vecteur vide au lieu  d'un vecteur
    avec un seul  caractère. Cela n'arrivera jamais dans  un vrai problème
    de Master Mot. Nous pouvons faire l'impasse sur ce bug.
- en: |
    Remark. If column <i>n</i> contains <var>x</var> instances of the same
    character,  the function  will return  an  empty vector  instead of  a
    1-char vector.  This will never happen  in a real Master  Mot problem.
    Therefore, we disregard this bug.
- section: 0
  fr: Génération des codes possibles de <var>n</var> caractères de long
  en: Generating the possible codes with length <var>n</var>
  level: 4
- fr: |
    La génération des  codes possibles de <var>n</var>  caractères se fait
    en prenant  les codes possibles de  <var>n</var> - 1 caractères  et en
    ajoutant un dernier caractère provenant de <tt>@master∆letters@ n</tt>.

    De  par  son  fonctionnement,  la  fonction  <tt>@master∆letters@</tt>
    renvoie un résultat trié. Donc les  codes possibles à 1 caractère sont
    eux aussi triés.  Essayons de conserver cette propriété  pour la liste
    des codes possibles à <var>n</var> caractères.

    Supposons que la liste des codes possibles à 3 caractères soit
- en: |
    To generate  the possible codes  with <var>n</var> chars,  the program
    begins with the list of possible codes with <var>n</var> - 1 chars and
    concatenate them with the chars from <tt>@master∆letters@ n</tt>.

    Because  of the  way  <tt>@master∆letters@</tt> works,  its result  is
    sorted. Therefore the 1-char possible codes are sorted. We try to keep
    this property with the <var>n</var>-char possible codes

    Let us suppose that the 3-char possible codes are
- code: |
     abc
     def
     ghi
- fr: |
     et que la liste (triée) des lettres en colonne 4 soit
- en: |
     and that the (sorted) list of letters for column 4 is
- code: |
     wxyz
- fr: |
    Le résultat attendu est :
- en: |
    The expected result is:
- code: |
     abcw
     abcx
     abcy
     abcz
     defw
     defx
     defy
     defz
     ghiw
     ghix
     ghiy
     ghiz
- fr: |
    Cela se fait en indexant la liste des codes possibles à 3 lettres par
- en: |
    For this, we index the list of 3-char possible codes with
- code: |
     1 1 1 1 2 2 2 2 3 3 3 3
- fr: |
    c'est-à-dire les  nombres 1 à  3 (car  3 possibilités) répétés  4 fois
    (car 4 lettres dans la colonne  ajoutée) et en indexant les lettres de
    la colonne 4 par
- en: |
   that is,  numbers 1 to  3 (because 3  possible codes) repeated  4 times
   (because 4  added letters) and at  the same time we  index the column-4
   letters with
- code: |
     1 2 3 4 1 2 3 4 1 2 3 4
- fr: |
    c'est-à-dire les nombres 1  à 4 (car 4 lettres) répétés  3 fois (car 3
    possibilités dans la génération précédente).
- en: |
    that is, numbers 1 to 4  (because 4 letters) repeated 3 times (because
    3 possible codes in the previous generation).
- section: master∆generation
  master.apl: 6
  level: 4
- fr: |
    Combien de codes possibles et combien de nouvelles lettres ?
- en: |
    How many possible codes and how many new letters?
- code: |
    ∇ r ← poss master∆generation letters; np; nl; ip; il
    np ← ¯1 ↓ ⍴ poss
    nl ← ⍴ letters
- fr: |
    Indices pour les codes possibles et pour les lettres
- en: |
    Indexing the possible codes and the letters.
- code: |
    ip ← (np × nl) ⍴ ⍳ np
    il ← (np × nl) ⍴ ⍳ nl
    ip ← ip[⍋ip]
- fr: |
    Concaténation des codes possibles de la génération précédente avec les
    lettres
- en: |
    Concatenating the possible codes from the previous generation with the
    new letters.
- code: |
    r ← poss[ip;] , letters[il]
    ∇
